<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/DOCKER_README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DOCKER_README.md" />
              <option name="updatedContent" value="# Vibeton - Инструкции по запуску&#10;&#10;## Быстрый старт&#10;&#10;### 1. Запуск всего приложения&#10;```bash&#10;docker compose up --build&#10;```&#10;&#10;### 2. Запуск в фоновом режиме&#10;```bash&#10;docker compose up -d --build&#10;```&#10;&#10;### 3. Остановка приложения&#10;```bash&#10;docker compose down&#10;```&#10;&#10;### 4. Остановка с удалением volumes (очистка БД)&#10;```bash&#10;docker compose down -v&#10;```&#10;&#10;## Доступные сервисы&#10;&#10;- **Backend API**: http://localhost:8000&#10;- **Swagger UI**: http://localhost:8000/swagger/index.html&#10;- **PostgreSQL**: localhost:5432&#10;&#10;## Использование Makefile&#10;&#10;Для удобства разработки используйте команды Makefile:&#10;&#10;```bash&#10;# Показать все доступные команды&#10;make help&#10;&#10;# Генерировать Swagger документацию&#10;make swagger&#10;&#10;# Запустить приложение локально (с генерацией Swagger)&#10;make run&#10;&#10;# Запустить только PostgreSQL для разработки&#10;make dev-db&#10;&#10;# Собрать Docker образ&#10;make docker-build&#10;&#10;# Запустить с Docker Compose&#10;make docker-run&#10;&#10;# Остановить Docker Compose&#10;make docker-stop&#10;```&#10;&#10;## API Документация&#10;&#10;После запуска приложения документация API доступна по адресу:&#10;- **Swagger UI**: http://localhost:8000/swagger/index.html&#10;&#10;Документация автоматически генерируется из аннотаций в коде и включает:&#10;- Описание всех endpoints&#10;- Модели данных&#10;- Примеры запросов и ответов&#10;- Возможность тестирования API прямо в браузере&#10;&#10;## Переменные окружения&#10;&#10;Вы можете изменить настройки в файле `docker-compose.yml`:&#10;&#10;### Сервер&#10;- `SERVER_HOST`: Хост сервера (по умолчанию: 0.0.0.0)&#10;- `SERVER_PORT`: Порт сервера (по умолчанию: 8000)&#10;&#10;### База данных&#10;- `DB_HOST`: Хост БД (по умолчанию: postgres)&#10;- `DB_PORT`: Порт БД (по умолчанию: 5432)&#10;- `DB_USER`: Пользователь БД (по умолчанию: vibeton_user)&#10;- `DB_PASS`: Пароль БД (по умолчанию: vibeton_password)&#10;- `DB_NAME`: Имя БД (по умолчанию: vibeton_db)&#10;&#10;## Разработка&#10;&#10;### Локальная разработка&#10;```bash&#10;# 1. Запустить только PostgreSQL&#10;make dev-db&#10;&#10;# 2. Установить инструменты для разработки&#10;make install-tools&#10;&#10;# 3. Запустить приложение локально&#10;make run&#10;```&#10;&#10;### Добавление новых API endpoints&#10;&#10;1. Добавьте методы в соответствующий handler&#10;2. Добавьте Swagger аннотации в комментариях:&#10;```go&#10;// CreateUser создает нового пользователя&#10;// @Summary Создать пользователя&#10;// @Description Создает нового пользователя в системе&#10;// @Tags users&#10;// @Accept json&#10;// @Produce json&#10;// @Param user body models.CreateUserRequest true &quot;Данные пользователя&quot;&#10;// @Success 201 {object} models.UserResponse&#10;// @Failure 400 {object} ErrorResponse&#10;// @Router /users [post]&#10;func (h *UserHandler) CreateUser(c *gin.Context) {&#10;    // реализация&#10;}&#10;```&#10;3. Перегенерируйте документацию: `make swagger`&#10;&#10;## Полезные команды&#10;&#10;### Просмотр логов&#10;```bash&#10;# Логи всех сервисов&#10;docker compose logs&#10;&#10;# Логи конкретного сервиса&#10;docker compose logs backend&#10;docker compose logs postgres&#10;&#10;# Логи в реальном времени&#10;make docker-logs&#10;```&#10;&#10;### Выполнение команд в контейнере&#10;```bash&#10;# Подключение к контейнеру с приложением&#10;docker compose exec backend sh&#10;&#10;# Подключение к PostgreSQL&#10;docker compose exec postgres psql -U vibeton_user -d vibeton_db&#10;```&#10;&#10;## Troubleshooting&#10;&#10;### Проблемы с Swagger&#10;- Убедитесь, что установлен swag CLI: `make install-tools`&#10;- Перегенерируйте документацию: `make swagger`&#10;- Проверьте корректность аннотаций в коде&#10;&#10;### Проблемы с подключением к БД&#10;- Убедитесь, что PostgreSQL запущен и готов к подключениям&#10;- Проверьте логи: `docker compose logs postgres`&#10;&#10;### Очистка всех данных&#10;```bash&#10;make docker-clean&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# Запуск приложения&#10;&#10;## Быстрый старт&#10;&#10;```bash&#10;# Запустить все сервисы&#10;docker compose up --build&#10;&#10;# Запустить в фоновом режиме&#10;docker compose up -d --build&#10;```&#10;&#10;## Доступные сервисы&#10;&#10;- **Backend API**: http://localhost:8000&#10;- **Swagger UI**: http://localhost:8080&#10;- **PostgreSQL**: localhost:5432&#10;&#10;## Остановка&#10;&#10;```bash&#10;docker compose down&#10;```&#10;&#10;## Очистка данных&#10;&#10;```bash&#10;docker compose down -v&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/Dockerfile" />
              <option name="originalContent" value="# Этап сборки&#10;FROM golang:1.24-alpine AS builder&#10;&#10;WORKDIR /app&#10;&#10;# Копируем зависимости&#10;COPY go.mod go.sum ./&#10;RUN go mod download&#10;&#10;# Копируем код&#10;COPY . .&#10;&#10;# Собираем приложение&#10;RUN CGO_ENABLED=0 GOOS=linux go build -o main cmd/api/main.go&#10;&#10;# Финальный образ&#10;FROM alpine:latest&#10;WORKDIR /root/&#10;&#10;COPY --from=builder /app/main .&#10;&#10;EXPOSE 8000&#10;&#10;CMD [&quot;./main&quot;]&#10;" />
              <option name="updatedContent" value="# Этап сборки&#10;FROM golang:1.21-alpine AS builder&#10;&#10;WORKDIR /app&#10;&#10;# Копируем зависимости&#10;COPY go.mod go.sum ./&#10;RUN go mod download&#10;&#10;# Копируем код&#10;COPY . .&#10;&#10;# Собираем приложение&#10;RUN CGO_ENABLED=0 GOOS=linux go build -o main cmd/api/main.go&#10;&#10;# Финальный образ&#10;FROM alpine:latest&#10;RUN apk --no-cache add ca-certificates&#10;WORKDIR /root/&#10;&#10;COPY --from=builder /app/main .&#10;&#10;EXPOSE 8000&#10;&#10;CMD [&quot;./main&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/Makefile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/Makefile" />
              <option name="originalContent" value=".PHONY: build run test clean docker-build docker-run migrate drop seed&#10;&#10;# Переменные&#10;APP_NAME=backend&#10;DOCKER_IMAGE=backend-app&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_USER=postgres&#10;DB_PASS=postgres&#10;DB_NAME=postgres&#10;&#10;# Сборка приложения&#10;build:&#10;&#9;go build -o bin/$(APP_NAME) cmd/api/main.go&#10;&#10;# Запуск приложения&#10;run:&#10;&#9;go run cmd/api/main.go&#10;&#10;# Запуск тестов&#10;test:&#10;&#9;go test -v ./...&#10;&#10;# Очистка&#10;clean:&#10;&#9;rm -rf bin/&#10;&#10;# Сборка Docker образа&#10;docker-build:&#10;&#9;docker build -t $(DOCKER_IMAGE) .&#10;&#10;# Запуск в Docker&#10;docker-run:&#10;&#9;docker run -p 8000:8000 $(DOCKER_IMAGE)&#10;&#10;# Команды для управления базой данных&#10;migrate:&#10;&#9;go run cmd/migrate/main.go -command=migrate&#10;&#10;drop:&#10;&#9;go run cmd/migrate/main.go -command=drop&#10;&#10;seed:&#10;&#9;go run cmd/migrate/main.go -command=seed&#10;&#10;# Загрузка зависимостей&#10;deps:&#10;&#9;go mod download&#10;&#9;go mod tidy&#10;&#10;# Создание новой миграции (требует golang-migrate)&#10;create-migration:&#10;&#9;migrate create -ext sql -dir migrations -seq $(name)&#10;&#10;# Форматирование кода&#10;fmt:&#10;&#9;go fmt ./...&#10;&#10;# Линтер&#10;lint:&#10;&#9;golangci-lint run&#10;&#10;# Запуск всего через Docker Compose&#10;up:&#10;&#9;docker-compose up --build&#10;&#10;# Остановка Docker Compose&#10;down:&#10;&#9;docker-compose down&#10;&#10;# Логи Docker Compose&#10;logs:&#10;&#9;docker-compose logs -f&#10;&#10;# Перезапуск только бэкенда&#10;restart-backend:&#10;&#9;docker-compose restart app&#10;&#10;# Подключение к базе данных в Docker&#10;db-connect:&#10;&#9;docker-compose exec db psql -U $(DB_USER) -d $(DB_NAME)&#10;&#10;# Создание резервной копии БД&#10;db-backup:&#10;&#9;docker-compose exec db pg_dump -U $(DB_USER) $(DB_NAME) &gt; backup_$(shell date +%Y%m%d_%H%M%S).sql&#10;&#10;# Восстановление БД из резервной копии&#10;db-restore:&#10;&#9;docker-compose exec -T db psql -U $(DB_USER) -d $(DB_NAME) &lt; $(file)&#10;" />
              <option name="updatedContent" value=".PHONY: help build run clean test swagger docker-build docker-run docker-clean&#10;&#10;# Переменные&#10;APP_NAME=vibeton-backend&#10;DOCKER_IMAGE=vibeton/backend&#10;SWAGGER_VERSION=latest&#10;&#10;help: ## Показать справку&#10;&#9;@echo &quot;Доступные команды:&quot;&#10;&#9;@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = &quot;:.*?## &quot;}; {printf &quot;\033[36m%-20s\033[0m %s\n&quot;, $$1, $$2}'&#10;&#10;install-tools: ## Установить необходимые инструменты&#10;&#9;go install github.com/swaggo/swag/cmd/swag@latest&#10;&#10;swagger: ## Генерировать Swagger документацию&#10;&#9;swag init -g cmd/api/main.go -o docs&#10;&#10;build: swagger ## Собрать приложение&#10;&#9;go build -o bin/api cmd/api/main.go&#10;&#9;go build -o bin/migrate cmd/migrate/main.go&#10;&#10;run: swagger ## Запустить приложение локально&#10;&#9;go run cmd/api/main.go&#10;&#10;run-migrate: ## Запустить миграции&#10;&#9;go run cmd/migrate/main.go&#10;&#10;test: ## Запустить тесты&#10;&#9;go test ./...&#10;&#10;clean: ## Очистить артефакты сборки&#10;&#9;rm -rf bin/&#10;&#9;rm -rf docs/&#10;&#10;# Docker команды&#10;docker-build: ## Собрать Docker образ&#10;&#9;docker build -t $(DOCKER_IMAGE) .&#10;&#10;docker-run: ## Запустить с Docker Compose&#10;&#9;docker compose up --build&#10;&#10;docker-run-bg: ## Запустить в фоне с Docker Compose&#10;&#9;docker compose up -d --build&#10;&#10;docker-stop: ## Остановить Docker Compose&#10;&#9;docker compose down&#10;&#10;docker-clean: ## Очистить Docker ресурсы&#10;&#9;docker compose down -v&#10;&#9;docker system prune -f&#10;&#10;docker-logs: ## Показать логи&#10;&#9;docker compose logs -f backend&#10;&#10;# Разработка&#10;dev-db: ## Запустить только базу данных для разработки&#10;&#9;docker compose up postgres -d&#10;&#10;mod-tidy: ## Привести в порядок go.mod&#10;&#9;go mod tidy&#10;&#10;fmt: ## Форматировать код&#10;&#9;go fmt ./...&#10;&#10;lint: ## Проверить код линтером&#10;&#9;golangci-lint run" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/cmd/api/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/cmd/api/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;backend/internal/api&quot;&#10;&#9;&quot;backend/internal/business&quot;&#10;&#9;&quot;backend/internal/config&quot;&#10;&#9;&quot;backend/internal/database&quot;&#10;&#9;&quot;backend/internal/repository&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#10;&#9;_ &quot;backend/docs&quot; // Импорт для Swagger документации&#10;)&#10;&#10;func main() {&#10;&#9;// Загружаем конфигурацию&#10;&#9;cfg := config.Load()&#10;&#10;&#9;// Подключаемся к базе данных&#10;&#9;db := database.NewDatabase(cfg)&#10;&#9;defer db.Close()&#10;&#10;&#9;// Выполняем миграции&#10;&#9;if err := db.Migrate(); err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to migrate database: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Инициализируем слои&#10;&#9;userRepo := repository.NewUserRepository(db.DB)&#10;&#9;userService := business.NewUserService(userRepo)&#10;&#10;&#9;// Создаем и запускаем сервер&#10;&#9;server := api.NewServer(userService)&#10;&#10;&#9;addr := fmt.Sprintf(&quot;%s:%s&quot;, cfg.Server.Host, cfg.Server.Port)&#10;&#9;log.Printf(&quot;Server starting on %s&quot;, addr)&#10;&#10;&#9;if err := server.Run(addr); err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to start server: %v&quot;, err)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;backend/internal/api&quot;&#10;&#9;&quot;backend/internal/business&quot;&#10;&#9;&quot;backend/internal/config&quot;&#10;&#9;&quot;backend/internal/database&quot;&#10;&#9;&quot;backend/internal/repository&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#10;&#9;_ &quot;backend/docs&quot; // Импорт для Swagger документации&#10;)&#10;&#10;func main() {&#10;&#9;// Загружаем конфигурацию&#10;&#9;cfg := config.Load()&#10;&#10;&#9;// Подключаемся к базе данных&#10;&#9;db := database.NewDatabase(cfg)&#10;&#9;defer db.Close()&#10;&#10;&#9;// Выполняем миграции&#10;&#9;if err := db.Migrate(); err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to migrate database: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Инициализируем слои&#10;&#9;userRepo := repository.NewUserRepository(db.DB)&#10;&#9;userService := business.NewUserService(userRepo)&#10;&#10;&#9;// Создаем и запускаем сервер&#10;&#9;server := api.NewServer(userService)&#10;&#10;&#9;addr := fmt.Sprintf(&quot;%s:%s&quot;, cfg.Server.Host, cfg.Server.Port)&#10;&#9;log.Printf(&quot;Server starting on %s&quot;, addr)&#10;&#10;&#9;if err := server.Run(addr); err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to start server: %v&quot;, err)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/docker-entrypoint.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/docker-entrypoint.sh" />
              <option name="updatedContent" value="#!/bin/sh&#10;&#10;echo &quot;Waiting for PostgreSQL to be ready...&quot;&#10;&#10;# Ждем, пока PostgreSQL будет готов&#10;until pg_isready -h $DB_HOST -p $DB_PORT -U $DB_USER&#10;do&#10;  echo &quot;PostgreSQL is unavailable - sleeping&quot;&#10;  sleep 1&#10;done&#10;&#10;echo &quot;PostgreSQL is up - executing migrations&quot;&#10;&#10;# Выполняем миграции&#10;./migrate&#10;&#10;echo &quot;Migrations completed - starting API server&quot;&#10;&#10;# Запускаем API сервер&#10;exec ./api" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/go.mod">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/go.mod" />
              <option name="originalContent" value="module backend&#10;&#10;go 1.24.0&#10;&#10;toolchain go1.24.5&#10;&#10;require (&#10;&#9;github.com/gin-gonic/gin v1.10.1&#10;&#9;github.com/swaggo/files v1.0.1&#10;&#9;github.com/swaggo/gin-swagger v1.6.1&#10;&#9;github.com/swaggo/swag v1.16.6&#10;&#9;golang.org/x/crypto v0.42.0&#10;&#9;gorm.io/driver/postgres v1.6.0&#10;&#9;gorm.io/gorm v1.31.0&#10;)&#10;&#10;require (&#10;&#9;github.com/KyleBanks/depth v1.2.1 // indirect&#10;&#9;github.com/PuerkitoBio/purell v1.1.1 // indirect&#10;&#9;github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect&#10;&#9;github.com/bytedance/sonic v1.11.6 // indirect&#10;&#9;github.com/bytedance/sonic/loader v0.1.1 // indirect&#10;&#9;github.com/cloudwego/base64x v0.1.4 // indirect&#10;&#9;github.com/cloudwego/iasm v0.2.0 // indirect&#10;&#9;github.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d // indirect&#10;&#9;github.com/gabriel-vasile/mimetype v1.4.3 // indirect&#10;&#9;github.com/gin-contrib/sse v0.1.0 // indirect&#10;&#9;github.com/go-openapi/jsonpointer v0.19.5 // indirect&#10;&#9;github.com/go-openapi/jsonreference v0.19.6 // indirect&#10;&#9;github.com/go-openapi/spec v0.20.4 // indirect&#10;&#9;github.com/go-openapi/swag v0.19.15 // indirect&#10;&#9;github.com/go-playground/locales v0.14.1 // indirect&#10;&#9;github.com/go-playground/universal-translator v0.18.1 // indirect&#10;&#9;github.com/go-playground/validator/v10 v10.20.0 // indirect&#10;&#9;github.com/goccy/go-json v0.10.2 // indirect&#10;&#9;github.com/jackc/pgpassfile v1.0.0 // indirect&#10;&#9;github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect&#10;&#9;github.com/jackc/pgx/v5 v5.6.0 // indirect&#10;&#9;github.com/jackc/puddle/v2 v2.2.2 // indirect&#10;&#9;github.com/jinzhu/inflection v1.0.0 // indirect&#10;&#9;github.com/jinzhu/now v1.1.5 // indirect&#10;&#9;github.com/josharian/intern v1.0.0 // indirect&#10;&#9;github.com/json-iterator/go v1.1.12 // indirect&#10;&#9;github.com/klauspost/cpuid/v2 v2.2.7 // indirect&#10;&#9;github.com/kr/text v0.2.0 // indirect&#10;&#9;github.com/leodido/go-urn v1.4.0 // indirect&#10;&#9;github.com/mailru/easyjson v0.7.6 // indirect&#10;&#9;github.com/mattn/go-isatty v0.0.20 // indirect&#10;&#9;github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect&#10;&#9;github.com/modern-go/reflect2 v1.0.2 // indirect&#10;&#9;github.com/pelletier/go-toml/v2 v2.2.2 // indirect&#10;&#9;github.com/rogpeppe/go-internal v1.14.1 // indirect&#10;&#9;github.com/russross/blackfriday/v2 v2.0.1 // indirect&#10;&#9;github.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect&#10;&#9;github.com/twitchyliquid64/golang-asm v0.15.1 // indirect&#10;&#9;github.com/ugorji/go/codec v1.2.12 // indirect&#10;&#9;github.com/urfave/cli/v2 v2.3.0 // indirect&#10;&#9;golang.org/x/arch v0.8.0 // indirect&#10;&#9;golang.org/x/mod v0.27.0 // indirect&#10;&#9;golang.org/x/net v0.43.0 // indirect&#10;&#9;golang.org/x/sync v0.17.0 // indirect&#10;&#9;golang.org/x/sys v0.36.0 // indirect&#10;&#9;golang.org/x/text v0.29.0 // indirect&#10;&#9;golang.org/x/tools v0.36.0 // indirect&#10;&#9;google.golang.org/protobuf v1.34.1 // indirect&#10;&#9;gopkg.in/yaml.v2 v2.4.0 // indirect&#10;&#9;gopkg.in/yaml.v3 v3.0.1 // indirect&#10;&#9;sigs.k8s.io/yaml v1.3.0 // indirect&#10;)&#10;" />
              <option name="updatedContent" value="module backend&#10;&#10;go 1.24.0&#10;&#10;toolchain go1.24.5&#10;&#10;require (&#10;&#9;github.com/gin-gonic/gin v1.10.1&#10;&#9;github.com/swaggo/files v1.0.1&#10;&#9;github.com/swaggo/gin-swagger v1.6.1&#10;&#9;github.com/swaggo/swag v1.16.6&#10;&#9;golang.org/x/crypto v0.42.0&#10;&#9;gorm.io/driver/postgres v1.6.0&#10;&#9;gorm.io/gorm v1.31.0&#10;)&#10;&#10;require (&#10;&#9;github.com/KyleBanks/depth v1.2.1 // indirect&#10;&#9;github.com/PuerkitoBio/purell v1.1.1 // indirect&#10;&#9;github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect&#10;&#9;github.com/bytedance/sonic v1.11.6 // indirect&#10;&#9;github.com/bytedance/sonic/loader v0.1.1 // indirect&#10;&#9;github.com/cloudwego/base64x v0.1.4 // indirect&#10;&#9;github.com/cloudwego/iasm v0.2.0 // indirect&#10;&#9;github.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d // indirect&#10;&#9;github.com/gabriel-vasile/mimetype v1.4.3 // indirect&#10;&#9;github.com/gin-contrib/sse v0.1.0 // indirect&#10;&#9;github.com/go-openapi/jsonpointer v0.19.5 // indirect&#10;&#9;github.com/go-openapi/jsonreference v0.19.6 // indirect&#10;&#9;github.com/go-openapi/spec v0.20.4 // indirect&#10;&#9;github.com/go-openapi/swag v0.19.15 // indirect&#10;&#9;github.com/go-playground/locales v0.14.1 // indirect&#10;&#9;github.com/go-playground/universal-translator v0.18.1 // indirect&#10;&#9;github.com/go-playground/validator/v10 v10.20.0 // indirect&#10;&#9;github.com/goccy/go-json v0.10.2 // indirect&#10;&#9;github.com/jackc/pgpassfile v1.0.0 // indirect&#10;&#9;github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect&#10;&#9;github.com/jackc/pgx/v5 v5.6.0 // indirect&#10;&#9;github.com/jackc/puddle/v2 v2.2.2 // indirect&#10;&#9;github.com/jinzhu/inflection v1.0.0 // indirect&#10;&#9;github.com/jinzhu/now v1.1.5 // indirect&#10;&#9;github.com/josharian/intern v1.0.0 // indirect&#10;&#9;github.com/json-iterator/go v1.1.12 // indirect&#10;&#9;github.com/klauspost/cpuid/v2 v2.2.7 // indirect&#10;&#9;github.com/kr/text v0.2.0 // indirect&#10;&#9;github.com/leodido/go-urn v1.4.0 // indirect&#10;&#9;github.com/mailru/easyjson v0.7.6 // indirect&#10;&#9;github.com/mattn/go-isatty v0.0.20 // indirect&#10;&#9;github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect&#10;&#9;github.com/modern-go/reflect2 v1.0.2 // indirect&#10;&#9;github.com/pelletier/go-toml/v2 v2.2.2 // indirect&#10;&#9;github.com/rogpeppe/go-internal v1.14.1 // indirect&#10;&#9;github.com/russross/blackfriday/v2 v2.0.1 // indirect&#10;&#9;github.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect&#10;&#9;github.com/twitchyliquid64/golang-asm v0.15.1 // indirect&#10;&#9;github.com/ugorji/go/codec v1.2.12 // indirect&#10;&#9;github.com/urfave/cli/v2 v2.3.0 // indirect&#10;&#9;golang.org/x/arch v0.8.0 // indirect&#10;&#9;golang.org/x/mod v0.27.0 // indirect&#10;&#9;golang.org/x/net v0.43.0 // indirect&#10;&#9;golang.org/x/sync v0.17.0 // indirect&#10;&#9;golang.org/x/sys v0.36.0 // indirect&#10;&#9;golang.org/x/text v0.29.0 // indirect&#10;&#9;golang.org/x/tools v0.36.0 // indirect&#10;&#9;google.golang.org/protobuf v1.34.1 // indirect&#10;&#9;gopkg.in/yaml.v2 v2.4.0 // indirect&#10;&#9;gopkg.in/yaml.v3 v3.0.1 // indirect&#10;&#9;sigs.k8s.io/yaml v1.3.0 // indirect&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/internal/api/responses.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/internal/api/responses.go" />
              <option name="updatedContent" value="package api&#10;&#10;// ErrorResponse представляет структуру ответа об ошибке&#10;type ErrorResponse struct {&#10;&#9;Error string `json:&quot;error&quot; example:&quot;описание ошибки&quot;`&#10;}&#10;&#10;// SuccessResponse представляет структуру успешного ответа&#10;type SuccessResponse struct {&#10;&#9;Message string `json:&quot;message&quot; example:&quot;операция выполнена успешно&quot;`&#10;}&#10;&#10;// ListResponse представляет структуру ответа со списком&#10;type ListResponse struct {&#10;&#9;Data  interface{} `json:&quot;data&quot;`&#10;&#9;Total int         `json:&quot;total&quot; example:&quot;100&quot;`&#10;&#9;Page  int         `json:&quot;page&quot; example:&quot;1&quot;`&#10;&#9;Limit int         `json:&quot;limit&quot; example:&quot;10&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/internal/api/server.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/internal/api/server.go" />
              <option name="originalContent" value="package api&#10;&#10;import (&#10;&#9;&quot;backend/internal/business&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;type Server struct {&#10;&#9;router      *gin.Engine&#10;&#9;userHandler *UserHandler&#10;}&#10;&#10;func NewServer(userService business.UserService) *Server {&#10;&#9;server := &amp;Server{&#10;&#9;&#9;router:      gin.Default(),&#10;&#9;&#9;userHandler: NewUserHandler(userService),&#10;&#9;}&#10;&#10;&#9;server.setupRoutes()&#10;&#9;return server&#10;}&#10;&#10;func (s *Server) setupRoutes() {&#10;&#9;// Добавляем middleware для CORS и логирования до определения маршрутов&#10;&#9;s.router.Use(CORSMiddleware())&#10;&#9;s.router.Use(gin.Logger())&#10;&#9;s.router.Use(gin.Recovery())&#10;&#10;&#9;api := s.router.Group(&quot;/api/v1&quot;)&#10;&#9;{&#10;&#9;&#9;users := api.Group(&quot;/users&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.POST(&quot;&quot;, s.userHandler.CreateUser)&#10;&#9;&#9;&#9;users.GET(&quot;&quot;, s.userHandler.ListUsers)&#10;&#9;&#9;&#9;users.GET(&quot;/:id&quot;, s.userHandler.GetUser)&#10;&#9;&#9;&#9;// Закомментированные маршруты, так как хендлеры для них отсутствуют&#10;&#9;&#9;&#9;// users.PUT(&quot;/:id&quot;, s.userHandler.UpdateUser)&#10;&#9;&#9;&#9;// users.DELETE(&quot;/:id&quot;, s.userHandler.DeleteUser)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;coworking := api.Group(&quot;/coworking&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;coworking.GET(&quot;/:id&quot;, s.userHandler.GetCoworking)&#10;&#9;&#9;&#9;coworking.PUT(&quot;/:id&quot;, s.userHandler.UpdateCoworking)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;func (s *Server) Run(addr string) error {&#10;&#9;return s.router.Run(addr)&#10;}&#10;&#10;func CORSMiddleware() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;c.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;&#9;&#9;c.Writer.Header().Set(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)&#10;&#9;&#9;c.Writer.Header().Set(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With&quot;)&#10;&#9;&#9;c.Writer.Header().Set(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, OPTIONS, GET, PUT, DELETE&quot;)&#10;&#10;&#9;&#9;if c.Request.Method == &quot;OPTIONS&quot; {&#10;&#9;&#9;&#9;c.AbortWithStatus(204)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package api&#10;&#10;import (&#10;&#9;&quot;backend/internal/business&quot;&#10;&#9;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;ginSwagger &quot;github.com/swaggo/gin-swagger&quot;&#10;&#9;&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;&#10;)&#10;&#10;// @title Vibeton API&#10;// @version 1.0&#10;// @description API для приложения Vibeton - коворкинг платформа&#10;// @termsOfService http://swagger.io/terms/&#10;&#10;// @contact.name API Support&#10;// @contact.url http://www.swagger.io/support&#10;// @contact.email support@swagger.io&#10;&#10;// @license.name Apache 2.0&#10;// @license.url http://www.apache.org/licenses/LICENSE-2.0.html&#10;&#10;// @host localhost:8000&#10;// @BasePath /api/v1&#10;// @schemes http&#10;&#10;type Server struct {&#10;&#9;router      *gin.Engine&#10;&#9;userHandler *UserHandler&#10;}&#10;&#10;func NewServer(userService business.UserService) *Server {&#10;&#9;server := &amp;Server{&#10;&#9;&#9;router:      gin.Default(),&#10;&#9;&#9;userHandler: NewUserHandler(userService),&#10;&#9;}&#10;&#10;&#9;server.setupRoutes()&#10;&#9;return server&#10;}&#10;&#10;func (s *Server) setupRoutes() {&#10;&#9;// Добавляем middleware для CORS и логирования до определения маршрутов&#10;&#9;s.router.Use(CORSMiddleware())&#10;&#9;s.router.Use(gin.Logger())&#10;&#9;s.router.Use(gin.Recovery())&#10;&#10;&#9;// Swagger документация&#10;&#9;s.router.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))&#10;&#10;&#9;// Основные API маршруты&#10;&#9;api := s.router.Group(&quot;/api/v1&quot;)&#10;&#9;{&#10;&#9;&#9;users := api.Group(&quot;/users&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.POST(&quot;&quot;, s.userHandler.CreateUser)&#10;&#9;&#9;&#9;users.GET(&quot;&quot;, s.userHandler.ListUsers)&#10;&#9;&#9;&#9;users.GET(&quot;/:id&quot;, s.userHandler.GetUser)&#10;&#9;&#9;&#9;// Закомментированные маршруты, так как хендлеры для них отсутствуют&#10;&#9;&#9;&#9;// users.PUT(&quot;/:id&quot;, s.userHandler.UpdateUser)&#10;&#9;&#9;&#9;// users.DELETE(&quot;/:id&quot;, s.userHandler.DeleteUser)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;coworking := api.Group(&quot;/coworking&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;coworking.GET(&quot;/:id&quot;, s.userHandler.GetCoworking)&#10;&#9;&#9;&#9;coworking.PUT(&quot;/:id&quot;, s.userHandler.UpdateCoworking)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;func (s *Server) Run(addr string) error {&#10;&#9;return s.router.Run(addr)&#10;}&#10;&#10;func CORSMiddleware() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;c.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;&#9;&#9;c.Writer.Header().Set(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)&#10;&#9;&#9;c.Writer.Header().Set(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With&quot;)&#10;&#9;&#9;c.Writer.Header().Set(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, OPTIONS, GET, PUT, DELETE&quot;)&#10;&#10;&#9;&#9;if c.Request.Method == &quot;OPTIONS&quot; {&#10;&#9;&#9;&#9;c.AbortWithStatus(204)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/internal/api/user_handler.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/internal/api/user_handler.go" />
              <option name="originalContent" value="package api&#10;&#10;import (&#10;&#9;&quot;backend/internal/business&quot;&#10;&#9;&quot;backend/internal/models&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;type UserHandler struct {&#10;&#9;userService business.UserService&#10;}&#10;&#10;func NewUserHandler(userService business.UserService) *UserHandler {&#10;&#9;return &amp;UserHandler{&#10;&#9;&#9;userService: userService,&#10;&#9;}&#10;}&#10;&#10;// CreateUser создает нового пользователя&#10;// @Summary Создать пользователя&#10;// @Description Создает нового пользователя в системе&#10;// @Tags users&#10;// @Accept json&#10;// @Produce json&#10;// @Param user body models.CreateUserRequest true &quot;Данные пользователя&quot;&#10;// @Success 201 {object} models.UserResponse&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 409 {object} ErrorResponse&#10;// @Router /users [post]&#10;func (h *UserHandler) CreateUser(c *gin.Context) {&#10;&#9;var req models.CreateUserRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;user, err := h.userService.CreateUser(&amp;req)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusCreated, user)&#10;}&#10;&#10;// GetUser получает пользователя по ID&#10;// @Summary Получить пользователя&#10;// @Description Получает пользователя по ID&#10;// @Tags users&#10;// @Produce json&#10;// @Param id path int true &quot;ID пользователя&quot;&#10;// @Success 200 {object} models.UserResponse&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 404 {object} ErrorResponse&#10;// @Router /users/{id} [get]&#10;func (h *UserHandler) GetUser(c *gin.Context) {&#10;&#9;idParam := c.Param(&quot;id&quot;)&#10;&#9;id, err := strconv.ParseUint(idParam, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: &quot;invalid user ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;user, err := h.userService.GetUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;var e *business.ServiceError&#10;&#9;&#9;if errors.As(err, &amp;e) {&#10;&#9;&#9;&#9;c.JSON(e.Code, ErrorResponse{Error: e.Message})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: &quot;internal server error&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, user)&#10;}&#10;&#10;// UpdateUser обновляет пользователя&#10;// @Summary Обновить пользователя&#10;// @Description Обновляет данные пользователя&#10;// @Tags users&#10;// @Accept json&#10;// @Produce json&#10;// @Param id path int true &quot;ID пользователя&quot;&#10;// @Param user body models.UpdateUserRequest true &quot;Обновленные данные&quot;&#10;// @Success 200 {object} models.UserResponse&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 404 {object} ErrorResponse&#10;// @Failure 409 {object} ErrorResponse&#10;// @Router /users/{id} [put]&#10;func (h *UserHandler) UpdateUser(c *gin.Context) {&#10;&#9;idParam := c.Param(&quot;id&quot;)&#10;&#9;id, err := strconv.ParseUint(idParam, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: &quot;invalid user ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var req models.UpdateUserRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;user, err := h.userService.UpdateUser(id, &amp;req)&#10;&#9;if err != nil {&#10;&#9;&#9;var e *business.ServiceError&#10;&#9;&#9;if errors.As(err, &amp;e) {&#10;&#9;&#9;&#9;c.JSON(e.Code, ErrorResponse{Error: e.Message})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: &quot;internal server error&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, user)&#10;}&#10;&#10;// DeleteUser удаляет пользователя&#10;// @Summary Удалить пользователя&#10;// @Description Удаляет пользоват��ля по ID&#10;// @Tags users&#10;// @Param id path int true &quot;ID пользователя&quot;&#10;// @Success 204&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 404 {object} ErrorResponse&#10;// @Router /users/{id} [delete]&#10;func (h *UserHandler) DeleteUser(c *gin.Context) {&#10;&#9;idParam := c.Param(&quot;id&quot;)&#10;&#9;id, err := strconv.ParseUint(idParam, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: &quot;invalid user ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;err = h.userService.DeleteUser(id)&#10;&#9;if err != nil {&#10;&#9;&#9;var e *business.ServiceError&#10;&#9;&#9;if errors.As(err, &amp;e) {&#10;&#9;&#9;&#9;c.JSON(e.Code, ErrorResponse{Error: e.Message})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: &quot;internal server error&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.Status(http.StatusNoContent)&#10;}&#10;&#10;// ListUsers получает список пользователей&#10;// @Summary Список пользователей&#10;// @Description Получает список пользователей с пагинацией&#10;// @Tags users&#10;// @Produce json&#10;// @Param page query int false &quot;Номер страницы&quot; default(1)&#10;// @Param page_size query int false &quot;Размер страницы&quot; default(10)&#10;// @Success 200 {object} UserListResponse&#10;// @Failure 400 {object} ErrorResponse&#10;// @Router /users [get]&#10;func (h *UserHandler) ListUsers(c *gin.Context) {&#10;&#9;page := 1&#10;&#9;pageSize := 10&#10;&#10;&#9;if pageParam := c.Query(&quot;page&quot;); pageParam != &quot;&quot; {&#10;&#9;&#9;if p, err := strconv.Atoi(pageParam); err == nil &amp;&amp; p &gt; 0 {&#10;&#9;&#9;&#9;page = p&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if sizeParam := c.Query(&quot;page_size&quot;); sizeParam != &quot;&quot; {&#10;&#9;&#9;if s, err := strconv.Atoi(sizeParam); err == nil &amp;&amp; s &gt; 0 &amp;&amp; s &lt;= 100 {&#10;&#9;&#9;&#9;pageSize = s&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;users, total, err := h.userService.ListUsers(page, pageSize)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: &quot;failed to list users&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;response := UserListResponse{&#10;&#9;&#9;Users: users,&#10;&#9;&#9;Pagination: PaginationInfo{&#10;&#9;&#9;&#9;Page:       page,&#10;&#9;&#9;&#9;PageSize:   pageSize,&#10;&#9;&#9;&#9;Total:      total,&#10;&#9;&#9;&#9;TotalPages: (total + int64(pageSize) - 1) / int64(pageSize),&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, response)&#10;}&#10;&#10;// GetCoworking получает коворкинг по ID&#10;// @Summary Получить коворкинг&#10;// @Description Получает коворкинг по ID&#10;// @Tags coworking&#10;// @Produce json&#10;// @Param id path int true &quot;ID коворкинга&quot;&#10;// @Success 200 {object} models.Coworking&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 404 {object} ErrorResponse&#10;// @Router /coworking/{id} [get]&#10;func (h *UserHandler) GetCoworking(c *gin.Context) {&#10;&#9;idParam := c.Param(&quot;id&quot;)&#10;&#9;id, err := strconv.ParseUint(idParam, 10, 32)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: &quot;invalid coworking ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;coworking, err := h.userService.GetCoworking(uint(id))&#10;&#9;if err != nil {&#10;&#9;&#9;var e *business.ServiceError&#10;&#9;&#9;if errors.As(err, &amp;e) {&#10;&#9;&#9;&#9;c.JSON(e.Code, ErrorResponse{Error: e.Message})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: &quot;internal server error&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, coworking)&#10;}&#10;&#10;// UpdateCoworking обновляет коворкинг&#10;// @Summary Обновить коворкинг&#10;// @Description Обновляет данные коворкинга&#10;// @Tags coworking&#10;// @Accept json&#10;// @Produce json&#10;// @Param id path int true &quot;ID коворкинга&quot;&#10;// @Param coworking body models.UpdateCoworkingRequest true &quot;Обновленные данные&quot;&#10;// @Success 200 {object} models.Coworking&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 404 {object} ErrorResponse&#10;// @Router /coworking/{id} [put]&#10;func (h *UserHandler) UpdateCoworking(c *gin.Context) {&#10;&#9;idParam := c.Param(&quot;id&quot;)&#10;&#9;id, err := strconv.ParseUint(idParam, 10, 32)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: &quot;invalid coworking ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var req models.UpdateCoworkingRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;coworking, err := h.userService.UpdateCoworking(uint(id), &amp;req)&#10;&#9;if err != nil {&#10;&#9;&#9;var e *business.ServiceError&#10;&#9;&#9;if errors.As(err, &amp;e) {&#10;&#9;&#9;&#9;c.JSON(e.Code, ErrorResponse{Error: e.Message})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: &quot;internal server error&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, coworking)&#10;}&#10;&#10;type ErrorResponse struct {&#10;&#9;Error string `json:&quot;error&quot;`&#10;}&#10;&#10;type UserListResponse struct {&#10;&#9;Users      []*models.UserResponse `json:&quot;users&quot;`&#10;&#9;Pagination PaginationInfo         `json:&quot;pagination&quot;`&#10;}&#10;&#10;type PaginationInfo struct {&#10;&#9;Page       int   `json:&quot;page&quot;`&#10;&#9;PageSize   int   `json:&quot;page_size&quot;`&#10;&#9;Total      int64 `json:&quot;total&quot;`&#10;&#9;TotalPages int64 `json:&quot;total_pages&quot;`&#10;}&#10;" />
              <option name="updatedContent" value="package api&#10;&#10;import (&#10;&#9;&quot;backend/internal/business&quot;&#10;&#9;&quot;backend/internal/models&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;type UserHandler struct {&#10;&#9;userService business.UserService&#10;}&#10;&#10;func NewUserHandler(userService business.UserService) *UserHandler {&#10;&#9;return &amp;UserHandler{&#10;&#9;&#9;userService: userService,&#10;&#9;}&#10;}&#10;&#10;// CreateUser создает нового пользователя&#10;// @Summary Создать пользователя&#10;// @Description Создает нового пользователя в системе&#10;// @Tags users&#10;// @Accept json&#10;// @Produce json&#10;// @Param user body models.CreateUserRequest true &quot;Данные пользователя&quot;&#10;// @Success 201 {object} models.UserResponse&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 409 {object} ErrorResponse&#10;// @Router /users [post]&#10;func (h *UserHandler) CreateUser(c *gin.Context) {&#10;&#9;var req models.CreateUserRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;user, err := h.userService.CreateUser(&amp;req)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusCreated, user)&#10;}&#10;&#10;// GetUser получает пользователя по ID&#10;// @Summary Получить пользователя&#10;// @Description Получает пользователя по ID&#10;// @Tags users&#10;// @Produce json&#10;// @Param id path int true &quot;ID пользователя&quot;&#10;// @Success 200 {object} models.UserResponse&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 404 {object} ErrorResponse&#10;// @Router /users/{id} [get]&#10;func (h *UserHandler) GetUser(c *gin.Context) {&#10;&#9;idParam := c.Param(&quot;id&quot;)&#10;&#9;id, err := strconv.ParseUint(idParam, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: &quot;invalid user ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;user, err := h.userService.GetUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, user)&#10;}&#10;&#10;// UpdateUser обновляет пользователя&#10;// @Summary Обновить пользователя&#10;// @Description Обновляет данные пользователя&#10;// @Tags users&#10;// @Accept json&#10;// @Produce json&#10;// @Param id path int true &quot;ID пользователя&quot;&#10;// @Param user body models.UpdateUserRequest true &quot;Обновленные данные&quot;&#10;// @Success 200 {object} models.UserResponse&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 404 {object} ErrorResponse&#10;// @Failure 409 {object} ErrorResponse&#10;// @Router /users/{id} [put]&#10;func (h *UserHandler) UpdateUser(c *gin.Context) {&#10;&#9;idParam := c.Param(&quot;id&quot;)&#10;&#9;id, err := strconv.ParseUint(idParam, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: &quot;invalid user ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var req models.UpdateUserRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;user, err := h.userService.UpdateUser(id, &amp;req)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, user)&#10;}&#10;&#10;// DeleteUser удаляет пользователя&#10;// @Summary Удалить пользователя&#10;// @Description Удаляет пользоват��ля по ID&#10;// @Tags users&#10;// @Param id path int true &quot;ID пользователя&quot;&#10;// @Success 204&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 404 {object} ErrorResponse&#10;// @Router /users/{id} [delete]&#10;func (h *UserHandler) DeleteUser(c *gin.Context) {&#10;&#9;idParam := c.Param(&quot;id&quot;)&#10;&#9;id, err := strconv.ParseUint(idParam, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: &quot;invalid user ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;err = h.userService.DeleteUser(id)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.Status(http.StatusNoContent)&#10;}&#10;&#10;// ListUsers получает список пользователей&#10;// @Summary Список пользователей&#10;// @Description Получает список пользователей с пагинацией&#10;// @Tags users&#10;// @Produce json&#10;// @Param page query int false &quot;Номер страницы&quot; default(1)&#10;// @Param page_size query int false &quot;Размер страницы&quot; default(10)&#10;// @Success 200 {object} UserListResponse&#10;// @Failure 400 {object} ErrorResponse&#10;// @Router /users [get]&#10;func (h *UserHandler) ListUsers(c *gin.Context) {&#10;&#9;page := 1&#10;&#9;pageSize := 10&#10;&#10;&#9;if pageParam := c.Query(&quot;page&quot;); pageParam != &quot;&quot; {&#10;&#9;&#9;if p, err := strconv.Atoi(pageParam); err == nil &amp;&amp; p &gt; 0 {&#10;&#9;&#9;&#9;page = p&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if sizeParam := c.Query(&quot;page_size&quot;); sizeParam != &quot;&quot; {&#10;&#9;&#9;if s, err := strconv.Atoi(sizeParam); err == nil &amp;&amp; s &gt; 0 &amp;&amp; s &lt;= 100 {&#10;&#9;&#9;&#9;pageSize = s&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;users, total, err := h.userService.ListUsers(page, pageSize)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;response := UserListResponse{&#10;&#9;&#9;Users: users,&#10;&#9;&#9;Pagination: PaginationInfo{&#10;&#9;&#9;&#9;Page:       page,&#10;&#9;&#9;&#9;PageSize:   pageSize,&#10;&#9;&#9;&#9;Total:      total,&#10;&#9;&#9;&#9;TotalPages: (total + int64(pageSize) - 1) / int64(pageSize),&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, response)&#10;}&#10;&#10;// GetCoworking получает коворкинг по ID&#10;// @Summary Получить коворкинг&#10;// @Description Получает коворкинг по ID&#10;// @Tags coworking&#10;// @Produce json&#10;// @Param id path int true &quot;ID коворкинга&quot;&#10;// @Success 200 {object} models.Coworking&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 404 {object} ErrorResponse&#10;// @Router /coworking/{id} [get]&#10;func (h *UserHandler) GetCoworking(c *gin.Context) {&#10;&#9;idParam := c.Param(&quot;id&quot;)&#10;&#9;id, err := strconv.ParseUint(idParam, 10, 32)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: &quot;invalid coworking ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;coworking, err := h.userService.GetCoworking(uint(id))&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, coworking)&#10;}&#10;&#10;// UpdateCoworking обновляет коворкинг&#10;// @Summary Обновить коворкинг&#10;// @Description Обновляет данные коворкинга&#10;// @Tags coworking&#10;// @Accept json&#10;// @Produce json&#10;// @Param id path int true &quot;ID коворкинга&quot;&#10;// @Param coworking body models.UpdateCoworkingRequest true &quot;Обновленные данные&quot;&#10;// @Success 200 {object} models.Coworking&#10;// @Failure 400 {object} ErrorResponse&#10;// @Failure 404 {object} ErrorResponse&#10;// @Router /coworking/{id} [put]&#10;func (h *UserHandler) UpdateCoworking(c *gin.Context) {&#10;&#9;idParam := c.Param(&quot;id&quot;)&#10;&#9;id, err := strconv.ParseUint(idParam, 10, 32)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: &quot;invalid coworking ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var req models.UpdateCoworkingRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;coworking, err := h.userService.UpdateCoworking(uint(id), &amp;req)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, ErrorResponse{Error: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, coworking)&#10;}&#10;&#10;type ErrorResponse struct {&#10;&#9;Error string `json:&quot;error&quot;`&#10;}&#10;&#10;type UserListResponse struct {&#10;&#9;Users      []*models.UserResponse `json:&quot;users&quot;`&#10;&#9;Pagination PaginationInfo         `json:&quot;pagination&quot;`&#10;}&#10;&#10;type PaginationInfo struct {&#10;&#9;Page       int   `json:&quot;page&quot;`&#10;&#9;PageSize   int   `json:&quot;page_size&quot;`&#10;&#9;Total      int64 `json:&quot;total&quot;`&#10;&#9;TotalPages int64 `json:&quot;total_pages&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/internal/models/user.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/internal/models/user.go" />
              <option name="originalContent" value="package models&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type UserRole string&#10;&#10;const (&#10;&#9;RoleUser  UserRole = &quot;user&quot;&#10;&#9;RoleAdmin UserRole = &quot;admin&quot;&#10;&#9;RoleMod   UserRole = &quot;moderator&quot;&#10;)&#10;&#10;type User struct {&#10;&#9;ID           uint64        `json:&quot;id&quot; gorm:&quot;primarykey&quot;` //telegrammid&#10;&#9;Username     string        `json:&quot;username&quot; gorm:&quot;uniqueIndex;not null&quot;`&#10;&#9;IsActive     bool          `json:&quot;is_active&quot; gorm:&quot;default:false&quot;`&#10;&#9;Role         UserRole      `json:&quot;role&quot; gorm:&quot;default:'user'&quot;`&#10;&#9;Achievements []Achievement `json:&quot;achievements&quot; gorm:&quot;foreignKey:UserID&quot;`&#10;&#9;Lvl          int           `json:&quot;lvl&quot; gorm:&quot;default:0&quot;`&#10;&#9;Xp           int           `json:&quot;xp&quot; gorm:&quot;default:0&quot;`&#10;&#9;Visits       int           `json:&quot;visits&quot; gorm:&quot;default:0&quot;` // количество визитов&#10;&#9;Donations    int           `json:&quot;donations&quot; gorm:&quot;default:0&quot;`&#10;&#9;CreatedAt    time.Time     `json:&quot;created_at&quot; gorm:&quot;autoCreateTime&quot;`&#10;&#9;UpdatedAt    time.Time     `json:&quot;updated_at&quot; gorm:&quot;autoUpdateTime&quot;`&#10;}&#10;type Achievement struct {&#10;&#9;ID          uint   `json:&quot;id&quot; gorm:&quot;primarykey&quot;`&#10;&#9;Name        string `json:&quot;name&quot; gorm:&quot;not null&quot;`&#10;&#9;Description string `json:&quot;description&quot;`&#10;&#9;Color       string `json:&quot;color&quot; gorm:&quot;default:'#3498db'&quot;` // HEX цвет&#10;}&#10;&#10;type CoworkingStatus string&#10;&#10;const (&#10;&#9;StatusOpen   CoworkingStatus = &quot;open&quot;&#10;&#9;StatusClosed CoworkingStatus = &quot;closed&quot;&#10;)&#10;&#10;type Coworking struct {&#10;&#9;ID                   uint            `json:&quot;id&quot; gorm:&quot;primarykey&quot;`&#10;&#9;Name                 string          `json:&quot;name&quot; gorm:&quot;not null&quot;`&#10;&#9;Status               CoworkingStatus `json:&quot;status&quot; gorm:&quot;default:'open'&quot;`&#10;&#9;Capacity             *int            `json:&quot;capacity&quot;`&#10;&#9;CurrentPeople        int             `json:&quot;current_people&quot; gorm:&quot;default:0&quot;`&#10;&#9;MonitorsTotal        int             `json:&quot;monitors_total&quot; gorm:&quot;default:0&quot;`&#10;&#9;MonitorsFree         int             `json:&quot;monitors_free&quot; gorm:&quot;default:0&quot;`&#10;&#9;PlaystationAvailable bool            `json:&quot;playstation_available&quot; gorm:&quot;default:true&quot;`&#10;&#9;ResponsibleUserID    *uint64         `json:&quot;responsible_user_id&quot;`&#10;&#9;ResponsibleUser      *User           `json:&quot;responsible_user,omitempty&quot; gorm:&quot;foreignKey:ResponsibleUserID&quot;`&#10;&#9;SupportContact       string          `json:&quot;support_contact&quot;`&#10;&#9;UpdatedAt            time.Time       `json:&quot;updated_at&quot;`&#10;}&#10;&#10;type CreateUserRequest struct {&#10;&#9;ID       uint64 `json:&quot;id&quot;`       // Telegram ID (primary key)&#10;&#9;Username string `json:&quot;username&quot;` // уникальный логин&#10;}&#10;type UserResponse struct {&#10;&#9;Username     string        `json:&quot;username&quot;`&#10;&#9;IsActive     bool          `json:&quot;is_active&quot;`&#10;&#9;Role         UserRole      `json:&quot;role&quot;`&#10;&#9;Achievements []Achievement `json:&quot;achievements,omitempty&quot;`&#10;&#9;Visits       int           `json:&quot;visits&quot;`&#10;&#9;Xp           int           `json:&quot;xp&quot;`&#10;&#9;Lvl          int           `json:&quot;lvl&quot;`&#10;}&#10;" />
              <option name="updatedContent" value="package models&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type UserRole string&#10;&#10;const (&#10;&#9;RoleUser  UserRole = &quot;user&quot;&#10;&#9;RoleAdmin UserRole = &quot;admin&quot;&#10;&#9;RoleMod   UserRole = &quot;moderator&quot;&#10;)&#10;&#10;type User struct {&#10;&#9;ID           uint64        `json:&quot;id&quot; gorm:&quot;primarykey&quot;` //telegrammid&#10;&#9;Username     string        `json:&quot;username&quot; gorm:&quot;uniqueIndex;not null&quot;`&#10;&#9;IsActive     bool          `json:&quot;is_active&quot; gorm:&quot;default:false&quot;`&#10;&#9;Role         UserRole      `json:&quot;role&quot; gorm:&quot;default:'user'&quot;`&#10;&#9;Achievements []Achievement `json:&quot;achievements&quot; gorm:&quot;foreignKey:UserID&quot;`&#10;&#9;Lvl          int           `json:&quot;lvl&quot; gorm:&quot;default:0&quot;`&#10;&#9;Xp           int           `json:&quot;xp&quot; gorm:&quot;default:0&quot;`&#10;&#9;Visits       int           `json:&quot;visits&quot; gorm:&quot;default:0&quot;` // количество визитов&#10;&#9;Donations    int           `json:&quot;donations&quot; gorm:&quot;default:0&quot;`&#10;&#9;CreatedAt    time.Time     `json:&quot;created_at&quot; gorm:&quot;autoCreateTime&quot;`&#10;&#9;UpdatedAt    time.Time     `json:&quot;updated_at&quot; gorm:&quot;autoUpdateTime&quot;`&#10;}&#10;type Achievement struct {&#10;&#9;ID          uint   `json:&quot;id&quot; gorm:&quot;primarykey&quot;`&#10;&#9;Name        string `json:&quot;name&quot; gorm:&quot;not null&quot;`&#10;&#9;Description string `json:&quot;description&quot;`&#10;&#9;Color       string `json:&quot;color&quot; gorm:&quot;default:'#3498db'&quot;` // HEX цвет&#10;}&#10;&#10;type CoworkingStatus string&#10;&#10;const (&#10;&#9;StatusOpen   CoworkingStatus = &quot;open&quot;&#10;&#9;StatusClosed CoworkingStatus = &quot;closed&quot;&#10;)&#10;&#10;type Coworking struct {&#10;&#9;ID                   uint            `json:&quot;id&quot; gorm:&quot;primarykey&quot;`&#10;&#9;Name                 string          `json:&quot;name&quot; gorm:&quot;not null&quot;`&#10;&#9;Status               CoworkingStatus `json:&quot;status&quot; gorm:&quot;default:'open'&quot;`&#10;&#9;Capacity             *int            `json:&quot;capacity&quot;`&#10;&#9;CurrentPeople        int             `json:&quot;current_people&quot; gorm:&quot;default:0&quot;`&#10;&#9;MonitorsTotal        int             `json:&quot;monitors_total&quot; gorm:&quot;default:0&quot;`&#10;&#9;MonitorsFree         int             `json:&quot;monitors_free&quot; gorm:&quot;default:0&quot;`&#10;&#9;PlaystationAvailable bool            `json:&quot;playstation_available&quot; gorm:&quot;default:true&quot;`&#10;&#9;ResponsibleUserID    *uint64         `json:&quot;responsible_user_id&quot;`&#10;&#9;ResponsibleUser      *User           `json:&quot;responsible_user,omitempty&quot; gorm:&quot;foreignKey:ResponsibleUserID&quot;`&#10;&#9;SupportContact       string          `json:&quot;support_contact&quot;`&#10;&#9;UpdatedAt            time.Time       `json:&quot;updated_at&quot;`&#10;}&#10;&#10;type CreateUserRequest struct {&#10;&#9;ID       uint64 `json:&quot;id&quot;`       // Telegram ID (primary key)&#10;&#9;Username string `json:&quot;username&quot;` // уникальный логин&#10;}&#10;&#10;type UpdateUserRequest struct {&#10;&#9;Username *string   `json:&quot;username,omitempty&quot;`&#10;&#9;IsActive *bool     `json:&quot;is_active,omitempty&quot;`&#10;&#9;Role     *UserRole `json:&quot;role,omitempty&quot;`&#10;}&#10;&#10;type UpdateCoworkingRequest struct {&#10;&#9;Name                 *string          `json:&quot;name,omitempty&quot;`&#10;&#9;Status               *CoworkingStatus `json:&quot;status,omitempty&quot;`&#10;&#9;Capacity             *int             `json:&quot;capacity,omitempty&quot;`&#10;&#9;CurrentPeople        *int             `json:&quot;current_people,omitempty&quot;`&#10;&#9;MonitorsTotal        *int             `json:&quot;monitors_total,omitempty&quot;`&#10;&#9;MonitorsFree         *int             `json:&quot;monitors_free,omitempty&quot;`&#10;&#9;PlaystationAvailable *bool            `json:&quot;playstation_available,omitempty&quot;`&#10;&#9;ResponsibleUserID    *uint64          `json:&quot;responsible_user_id,omitempty&quot;`&#10;&#9;SupportContact       *string          `json:&quot;support_contact,omitempty&quot;`&#10;}&#10;&#10;type UserResponse struct {&#10;&#9;ID           uint64        `json:&quot;id&quot;`&#10;&#9;Username     string        `json:&quot;username&quot;`&#10;&#9;IsActive     bool          `json:&quot;is_active&quot;`&#10;&#9;Role         UserRole      `json:&quot;role&quot;`&#10;&#9;Achievements []Achievement `json:&quot;achievements,omitempty&quot;`&#10;&#9;Visits       int           `json:&quot;visits&quot;`&#10;&#9;Xp           int           `json:&quot;xp&quot;`&#10;&#9;Lvl          int           `json:&quot;lvl&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/internal/repository/user_repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/internal/repository/user_repository.go" />
              <option name="originalContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;backend/internal/models&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type UserRepository interface {&#10;&#9;Create(user *models.User) error&#10;&#9;GetByID(id uint64) (*models.User, error)&#10;&#9;Update(user *models.User) error&#10;&#9;Delete(id uint) error&#10;&#9;List(offset, limit int) ([]*models.User, int64, error)&#10;&#9;CreateTables() error&#10;&#9;DropTables() error&#10;&#9;GetCoworking(id uint) (*models.Coworking, error)&#10;&#9;UpdateCoworking(coworking *models.Coworking) error&#10;&#9;&#10;}&#10;&#10;type userRepository struct {&#10;&#9;db *gorm.DB&#10;}&#10;&#10;func NewUserRepository(db *gorm.DB) UserRepository {&#10;&#9;return &amp;userRepository{db: db}&#10;}&#10;&#10;func (r *userRepository) Create(user *models.User) error {&#10;&#9;if err := r.db.Create(user).Error; err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func (r *userRepository) GetByID(id uint64) (*models.User, error) {&#10;&#9;var user models.User&#10;&#9;if err := r.db.First(&amp;user, id).Error; err != nil {&#10;&#9;&#9;if errors.Is(err, gorm.ErrRecordNotFound) {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;user not found&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;user, nil&#10;}&#10;&#10;func (r *userRepository) GetCoworking(id uint) (*models.Coworking, error) {&#10;&#9;var coworking models.Coworking&#10;&#9;if err := r.db.Preload(&quot;ResponsibleUser&quot;).First(&amp;coworking, id).Error; err != nil {&#10;&#9;&#9;if errors.Is(err, gorm.ErrRecordNotFound) {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;coworking not found&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;coworking, nil&#10;}&#10;&#10;func (r *userRepository) UpdateCoworking(coworking *models.Coworking) error {&#10;&#9;return r.db.Save(coworking).Error&#10;}&#10;&#10;func (r *userRepository) GetByUsername(username string) (*models.User, error) {&#10;&#9;var user models.User&#10;&#9;if err := r.db.Where(&quot;username = ?&quot;, username).First(&amp;user).Error; err != nil {&#10;&#9;&#9;if errors.Is(err, gorm.ErrRecordNotFound) {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;user not found&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;user, nil&#10;}&#10;&#10;func (r *userRepository) Update(user *models.User) error {&#10;&#9;return r.db.Save(user).Error&#10;}&#10;&#10;func (r *userRepository) Delete(id uint) error {&#10;&#9;return r.db.Delete(&amp;models.User{}, id).Error&#10;}&#10;&#10;func (r *userRepository) List(offset, limit int) ([]*models.User, int64, error) {&#10;&#9;var users []*models.User&#10;&#9;var total int64&#10;&#10;&#9;// Получаем общее количество записей&#10;&#9;if err := r.db.Model(&amp;models.User{}).Count(&amp;total).Error; err != nil {&#10;&#9;&#9;return nil, 0, err&#10;&#9;}&#10;&#10;&#9;// Получаем пользователей с пагинацией&#10;&#9;if err := r.db.Offset(offset).Limit(limit).Find(&amp;users).Error; err != nil {&#10;&#9;&#9;return nil, 0, err&#10;&#9;}&#10;&#10;&#9;return users, total, nil&#10;}&#10;&#10;// CreateTables создает таблицы в базе данных&#10;func (r *userRepository) CreateTables() error {&#10;&#9;return r.db.AutoMigrate(&amp;models.User{})&#10;}&#10;&#10;// DropTables удаляет таблицы из базы данных&#10;func (r *userRepository) DropTables() error {&#10;&#9;return r.db.Migrator().DropTable(&amp;models.User{})&#10;}&#10;" />
              <option name="updatedContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;backend/internal/models&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type UserRepository interface {&#10;&#9;Create(user *models.User) error&#10;&#9;GetByID(id uint64) (*models.User, error)&#10;&#9;GetByUsername(username string) (*models.User, error)&#10;&#9;Update(user *models.User) error&#10;&#9;Delete(id uint64) error&#10;&#9;List(offset, limit int) ([]*models.User, int64, error)&#10;&#9;CreateTables() error&#10;&#9;DropTables() error&#10;&#9;GetCoworking(id uint) (*models.Coworking, error)&#10;&#9;UpdateCoworking(coworking *models.Coworking) error&#10;}&#10;&#10;type userRepository struct {&#10;&#9;db *gorm.DB&#10;}&#10;&#10;func NewUserRepository(db *gorm.DB) UserRepository {&#10;&#9;return &amp;userRepository{db: db}&#10;}&#10;&#10;func (r *userRepository) Create(user *models.User) error {&#10;&#9;if err := r.db.Create(user).Error; err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func (r *userRepository) GetByID(id uint64) (*models.User, error) {&#10;&#9;var user models.User&#10;&#9;if err := r.db.First(&amp;user, id).Error; err != nil {&#10;&#9;&#9;if errors.Is(err, gorm.ErrRecordNotFound) {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;user not found&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;user, nil&#10;}&#10;&#10;func (r *userRepository) Update(user *models.User) error {&#10;&#9;return r.db.Save(user).Error&#10;}&#10;&#10;func (r *userRepository) Delete(id uint64) error {&#10;&#9;if err := r.db.Delete(&amp;models.User{}, id).Error; err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;if r.db.RowsAffected == 0 {&#10;&#9;&#9;return errors.New(&quot;user not found&quot;)&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func (r *userRepository) List(offset, limit int) ([]*models.User, int64, error) {&#10;&#9;var users []*models.User&#10;&#9;var total int64&#10;&#10;&#9;// Получаем общее количество записей&#10;&#9;if err := r.db.Model(&amp;models.User{}).Count(&amp;total).Error; err != nil {&#10;&#9;&#9;return nil, 0, err&#10;&#9;}&#10;&#10;&#9;// Получаем пользователей с пагинацией&#10;&#9;if err := r.db.Offset(offset).Limit(limit).Find(&amp;users).Error; err != nil {&#10;&#9;&#9;return nil, 0, err&#10;&#9;}&#10;&#10;&#9;return users, total, nil&#10;}&#10;&#10;// CreateTables создает таблицы в базе данных&#10;func (r *userRepository) CreateTables() error {&#10;&#9;return r.db.AutoMigrate(&amp;models.User{})&#10;}&#10;&#10;// DropTables удаляет таблицы из базы данных&#10;func (r *userRepository) DropTables() error {&#10;&#9;return r.db.Migrator().DropTable(&amp;models.User{})&#10;}&#10;&#10;func (r *userRepository) GetCoworking(id uint) (*models.Coworking, error) {&#10;&#9;var coworking models.Coworking&#10;&#9;if err := r.db.Preload(&quot;ResponsibleUser&quot;).First(&amp;coworking, id).Error; err != nil {&#10;&#9;&#9;if errors.Is(err, gorm.ErrRecordNotFound) {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;coworking not found&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;coworking, nil&#10;}&#10;&#10;func (r *userRepository) UpdateCoworking(coworking *models.Coworking) error {&#10;&#9;return r.db.Save(coworking).Error&#10;}&#10;&#10;func (r *userRepository) GetByUsername(username string) (*models.User, error) {&#10;&#9;var user models.User&#10;&#9;if err := r.db.Where(&quot;username = ?&quot;, username).First(&amp;user).Error; err != nil {&#10;&#9;&#9;if errors.Is(err, gorm.ErrRecordNotFound) {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;user not found&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;user, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/config/database.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/config/database.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/models/schemas.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/models/schemas.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/models/user.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/models/user.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docker-compose.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.yml" />
              <option name="originalContent" value="version: '3.8'&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:15-alpine&#10;    environment:&#10;      POSTGRES_DB: vibeton_db&#10;      POSTGRES_USER: vibeton_user&#10;      POSTGRES_PASSWORD: vibeton_password&#10;    ports:&#10;      - &quot;5432:5432&quot;&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;&#10;  backend:&#10;    build: ./backend&#10;    ports:&#10;      - &quot;8000:8000&quot;&#10;    environment:&#10;      DB_HOST: postgres&#10;      DB_PORT: 5432&#10;      DB_USER: vibeton_user&#10;      DB_PASS: vibeton_password&#10;      DB_NAME: vibeton_db&#10;      DB_SSLMODE: disable&#10;      SERVER_PORT: 8000&#10;      SERVER_HOST: 0.0.0.0&#10;    depends_on:&#10;      - postgres&#10;&#10;  swagger:&#10;    image: swaggerapi/swagger-ui:latest&#10;    ports:&#10;      - &quot;8080:8080&quot;&#10;    environment:&#10;      SWAGGER_JSON: /swagger/swagger.json&#10;      BASE_URL: /swagger&#10;    volumes:&#10;      - ./backend/docs:/swagger:ro&#10;&#10;volumes:&#10;  postgres_data:&#10;" />
              <option name="updatedContent" value="version: '3.8'&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:15-alpine&#10;    environment:&#10;      POSTGRES_DB: vibeton_db&#10;      POSTGRES_USER: vibeton_user&#10;      POSTGRES_PASSWORD: vibeton_password&#10;    ports:&#10;      - &quot;5432:5432&quot;&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;&#10;  backend:&#10;    build: ./backend&#10;    ports:&#10;      - &quot;8000:8000&quot;&#10;    environment:&#10;      DB_HOST: postgres&#10;      DB_PORT: 5432&#10;      DB_USER: vibeton_user&#10;      DB_PASS: vibeton_password&#10;      DB_NAME: vibeton_db&#10;      DB_SSLMODE: disable&#10;      SERVER_PORT: 8000&#10;      SERVER_HOST: 0.0.0.0&#10;    depends_on:&#10;      - postgres&#10;&#10;  swagger:&#10;    image: swaggerapi/swagger-ui:latest&#10;    ports:&#10;      - &quot;8080:8080&quot;&#10;    environment:&#10;      SWAGGER_JSON: /swagger/swagger.json&#10;      BASE_URL: /swagger&#10;    volumes:&#10;      - ./backend/docs:/swagger:ro&#10;&#10;volumes:&#10;  postgres_data:" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/Dockerfile" />
              <option name="updatedContent" value="# Используйте официальный образ Nginx&#10;FROM nginx:alpine&#10;&#10;# Копируйте статические файлы в каталог Nginx&#10;COPY . /usr/share/nginx/html&#10;&#10;# Откройте порт 80&#10;EXPOSE 80&#10;&#10;# Запустите Nginx&#10;CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/init.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/init.sql" />
              <option name="updatedContent" value="-- Инициализация базы данных для Vibeton&#10;-- Этот файл выполняется при первом запуске PostgreSQL контейнера&#10;&#10;-- Создаем схему, если она не существует&#10;CREATE SCHEMA IF NOT EXISTS public;&#10;&#10;-- Устанавливаем права доступа&#10;GRANT ALL PRIVILEGES ON SCHEMA public TO vibeton_user;&#10;GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO vibeton_user;&#10;GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO vibeton_user;&#10;&#10;-- Создаем расширения, которые могут понадобиться&#10;CREATE EXTENSION IF NOT EXISTS &quot;uuid-ossp&quot;;&#10;CREATE EXTENSION IF NOT EXISTS &quot;pgcrypto&quot;;&#10;&#10;-- Комментарий о назначении БД&#10;COMMENT ON DATABASE vibeton_db IS 'База данных для приложения Vibeton';" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>